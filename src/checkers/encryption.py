"""Encryption module."""

# This is the buffer module from https://github.com/py-mine/mcproto v0.5.0,
# which is licensed under the GNU LESSER GENERAL PUBLIC LICENSE v3.0

from __future__ import annotations

__author__ = "ItsDrike"
__license__ = "LGPL-3.0-only"

import os

from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric.padding import MGF1, OAEP
from cryptography.hazmat.primitives.asymmetric.rsa import (
    RSAPrivateKey as RSAPrivateKey,
    RSAPublicKey as RSAPublicKey,
    generate_private_key,
)
from cryptography.hazmat.primitives.hashes import SHA256
from cryptography.hazmat.primitives.serialization import (
    Encoding,
    PublicFormat,
    load_der_public_key,
)


def generate_shared_secret() -> bytes:  # pragma: no cover
    """Generate a random shared secret for client.

    This secret will be sent to the server in :class:`~mcproto.packets.login.login.LoginEncryptionResponse` packet,
    and used to encrypt all future communication afterwards.

    This will be symmetric encryption using AES/CFB8 stream cipher. And this shared secret will be 256-bits long.
    """
    return os.urandom(256 // 8)


def generate_verify_token() -> bytes:  # pragma: no cover
    """Generate a random verify token.

    This token will be sent by the server in :class:`~mcproto.packets.login.login.LoginEncryptionRequest`, to be
    encrypted by the client as a form of verification.

    This token doesn't need to be cryptographically secure, it's just a sanity check that
    the client has encrypted the data correctly.
    """
    return os.urandom(16)


def generate_rsa_key() -> RSAPrivateKey:  # pragma: no cover
    """Generate a random RSA key pair for server.

    This key pair will be used for :class:`~mcproto.packets.login.login.LoginEncryptionRequest` packet,
    where the client will be sent the public part of this key pair, which will be used to encrypt the
    shared secret (and verification token) sent in :class:`~mcproto.packets.login.login.LoginEncryptionResponse`
    packet. The server will then use the private part of this key pair to decrypt that.

    This will be a 2048-bit RSA key pair.
    """
    return generate_private_key(
        public_exponent=65537,
        key_size=2048,
        backend=default_backend(),
    )


def encrypt_with_rsa(
    public_key: RSAPublicKey,
    data: bytes,
) -> bytes:
    """Encrypt given data with given RSA public key."""
    return public_key.encrypt(
        bytes(data),
        OAEP(MGF1(SHA256()), SHA256(), None),
    )


def encrypt_token_and_secret(
    public_key: RSAPublicKey,
    verification_token: bytes,
    shared_secret: bytes,
) -> tuple[bytes, bytes]:
    """Encrypts the verification token and shared secret with the server's public key.

    :param public_key: The RSA public key provided by the server
    :param verification_token: The verification token provided by the server
    :param shared_secret: The generated shared secret
    :return: A tuple containing (encrypted token, encrypted secret)
    """
    encrypted_token = encrypt_with_rsa(public_key, verification_token)
    encrypted_secret = encrypt_with_rsa(public_key, shared_secret)
    return encrypted_token, encrypted_secret


def decrypt_with_rsa(
    private_key: RSAPrivateKey,
    data: bytes,
) -> bytes:
    """Decrypt given data with given RSA private key."""
    return private_key.decrypt(
        bytes(data),
        OAEP(MGF1(SHA256()), SHA256(), None),
    )


def decrypt_token_and_secret(
    private_key: RSAPrivateKey,
    verification_token: bytes,
    shared_secret: bytes,
) -> tuple[bytes, bytes]:
    """Decrypts the verification token and shared secret with the server's private key.

    :param private_key: The RSA private key generated by the server
    :param verification_token: The verification token encrypted and sent by the client
    :param shared_secret: The shared secret encrypted and sent by the client
    :return: A tuple containing (decrypted token, decrypted secret)
    """
    decrypted_token = decrypt_with_rsa(private_key, verification_token)
    decrypted_secret = decrypt_with_rsa(private_key, shared_secret)
    return decrypted_token, decrypted_secret


def serialize_public_key(
    public_key: RSAPublicKey,
) -> bytes:
    """Return public key serialize as bytes."""
    return public_key.public_bytes(
        encoding=Encoding.DER,
        format=PublicFormat.SubjectPublicKeyInfo,
    )


def deserialize_public_key(serialized_public_key: bytes) -> RSAPublicKey:
    """Return deserialized public key."""
    # Key type is determined by the passed key itself.
    # Should be be an RSA public key in this case.
    key = load_der_public_key(serialized_public_key, default_backend())
    assert isinstance(key, RSAPublicKey)
    return key
